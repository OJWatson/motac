from __future__ import annotations

import typer

from ._version import __version__

app = typer.Typer(add_completion=False, no_args_is_help=True)
substrate_app = typer.Typer(add_completion=False, no_args_is_help=True)
sim_app = typer.Typer(add_completion=False, no_args_is_help=True)
app.add_typer(substrate_app, name="substrate")
app.add_typer(sim_app, name="sim")


@app.callback()
def _root() -> None:
    """Road-constrained spatio-temporal Hawkes models (JAX)."""


@app.command()
def version() -> None:
    """Print the package version."""
    typer.echo(__version__)


@substrate_app.command("build")
def substrate_build(
    config: str = typer.Option(..., "--config", help="Path to substrate JSON config."),
) -> None:
    """Build (and optionally cache) the road-constrained substrate."""

    from .substrate import SubstrateBuilder, SubstrateConfig

    cfg = SubstrateConfig.from_json(config)
    substrate = SubstrateBuilder(cfg).build()

    typer.echo(f"grid_cells={len(substrate.grid.lat)}")
    nnz = substrate.neighbours.travel_time_s.nnz
    shape = substrate.neighbours.travel_time_s.shape
    typer.echo(f"neighbours_nnz={nnz} shape={shape}")
    if substrate.poi is None:
        typer.echo("poi=disabled")
    else:
        typer.echo(f"poi_features={substrate.poi.x.shape[1]}")


@sim_app.command("fit-kernel")
def sim_fit_kernel(
    parquet: str = typer.Option(..., "--parquet", help="Path to simulation parquet."),
    n_lags: int = typer.Option(6, "--n-lags", min=1, help="Kernel lag length."),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    init_beta: float = typer.Option(1.0, "--init-beta", min=0.0),
    maxiter: int = typer.Option(800, "--maxiter", min=1),
) -> None:
    """Fit (mu, alpha, beta) with an exponential kernel to a saved simulation."""

    import json

    import numpy as np

    from .sim import load_simulation_parquet
    from .sim.fit import fit_hawkes_mle_alpha_mu_beta

    loaded = load_simulation_parquet(path=parquet)
    world = loaded["world"]
    y = loaded["y_true"]

    fit = fit_hawkes_mle_alpha_mu_beta(
        world=world,
        n_lags=n_lags,
        y=y,
        init_alpha=init_alpha,
        init_beta=init_beta,
        maxiter=maxiter,
    )

    payload = {
        "mu": np.asarray(fit["mu"], dtype=float).tolist(),
        "alpha": float(fit["alpha"]),
        "beta": float(fit["beta"]),
        "loglik": float(fit["loglik"]),
        "loglik_init": float(fit["loglik_init"]),
        "success": bool(getattr(fit["result"], "success", False)),
        "message": str(getattr(fit["result"], "message", "")),
    }

    typer.echo(json.dumps(payload))


@sim_app.command("fit-observed")
def sim_fit_observed(
    parquet: str = typer.Option(..., "--parquet", help="Path to simulation parquet."),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    maxiter: int = typer.Option(600, "--maxiter", min=1),
) -> None:
    """Fit (mu, alpha) from y_obs using Poisson approximation.

    Requires that the parquet was generated by our simulator so that y_true is
    available to construct the Hawkes history term.
    """

    import json

    import numpy as np

    from .sim import load_simulation_parquet
    from .sim.fit import fit_hawkes_mle_alpha_mu_observed_poisson_approx

    loaded = load_simulation_parquet(path=parquet)
    world = loaded["world"]
    params = loaded["params"]

    fit = fit_hawkes_mle_alpha_mu_observed_poisson_approx(
        world=world,
        kernel=params.kernel,
        y_true_for_history=loaded["y_true"],
        y_obs=loaded["y_obs"],
        p_detect=float(params.p_detect),
        false_rate=float(params.false_rate),
        init_alpha=init_alpha,
        maxiter=maxiter,
    )

    payload = {
        "mu": np.asarray(fit["mu"], dtype=float).tolist(),
        "alpha": float(fit["alpha"]),
        "loglik": float(fit["loglik"]),
        "loglik_init": float(fit["loglik_init"]),
        "success": bool(getattr(fit["result"], "success", False)),
        "message": str(getattr(fit["result"], "message", "")),
    }

    typer.echo(json.dumps(payload))


def _load_y_obs(path: str):
    import numpy as np

    p = str(path)
    y = np.load(p) if p.endswith(".npy") else np.loadtxt(p, delimiter=",")

    y = np.asarray(y)
    if y.ndim != 2:
        raise ValueError("y_obs must be a 2D array (n_locations, n_steps)")
    return y


@sim_app.command("forecast-observed")
def sim_forecast_observed(
    y_obs_path: str = typer.Option(
        ..., "--y-obs", help="Path to y_obs as CSV (rows=locations) or .npy."
    ),
    horizon: int = typer.Option(20, "--horizon", min=1),
    n_paths: int = typer.Option(200, "--n-paths", min=1),
    seed: int = typer.Option(123, "--seed"),
    p_detect: float = typer.Option(1.0, "--p-detect", min=0.0, max=1.0),
    false_rate: float = typer.Option(0.0, "--false-rate", min=0.0),
    n_lags: int = typer.Option(6, "--n-lags", min=1),
    beta: float = typer.Option(1.0, "--beta", min=1e-12),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    maxiter: int = typer.Option(600, "--maxiter", min=1),
) -> None:
    """Observed-only forecast: fit -> sample -> summarize (Poisson approximation).

    Loads y_obs from CSV/NPY, fits (mu, alpha) under the Poisson-approx observed
    likelihood, samples predictive y_obs paths, and prints JSON containing the
    fitted params and predictive mean/quantiles.
    """

    import json

    import numpy as np

    from .sim import generate_random_world
    from .sim.hawkes import discrete_exponential_kernel
    from .sim.workflows import observed_fit_sample_summarize_poisson_approx

    y_obs = _load_y_obs(y_obs_path).astype(int)
    world = generate_random_world(n_locations=y_obs.shape[0], seed=0, lengthscale=0.5)
    kernel = discrete_exponential_kernel(n_lags=n_lags, beta=float(beta))

    out = observed_fit_sample_summarize_poisson_approx(
        world=world,
        kernel=kernel,
        y_obs=y_obs,
        p_detect=float(p_detect),
        false_rate=float(false_rate),
        horizon=int(horizon),
        n_paths=int(n_paths),
        seed=int(seed),
        init_alpha=float(init_alpha),
        fit_maxiter=int(maxiter),
    )

    fit = out["fit"]
    summary = out["summary"]

    payload = {
        "fit": {
            "mu": np.asarray(fit["mu"], dtype=float).tolist(),
            "alpha": float(fit["alpha"]),
            "loglik": float(fit["loglik"]),
            "loglik_init": float(fit["loglik_init"]),
            "success": bool(getattr(fit["result"], "success", False)),
            "message": str(getattr(fit["result"], "message", "")),
        },
        "predict": {
            "q": np.asarray(summary["q"], dtype=float).tolist(),
            "mean": np.asarray(summary["mean"], dtype=float).tolist(),
            "quantiles": np.asarray(summary["quantiles"], dtype=float).tolist(),
        },
    }

    typer.echo(json.dumps(payload))


def main() -> None:
    """Entry point for `motac`."""
    app()
