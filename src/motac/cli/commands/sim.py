from __future__ import annotations

import typer

from .._app import sim_app


@sim_app.command("fit-kernel")
def sim_fit_kernel(
    parquet: str = typer.Option(..., "--parquet", help="Path to simulation parquet."),
    n_lags: int = typer.Option(6, "--n-lags", min=1, help="Kernel lag length."),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    init_beta: float = typer.Option(1.0, "--init-beta", min=0.0),
    maxiter: int = typer.Option(800, "--maxiter", min=1),
) -> None:
    """Fit (mu, alpha, beta) with an exponential kernel to a saved simulation."""

    import json

    import numpy as np

    from ...sim import load_simulation_parquet
    from ...sim.fit import fit_hawkes_mle_alpha_mu_beta

    loaded = load_simulation_parquet(path=parquet)
    world = loaded["world"]
    y = loaded["y_true"]

    fit = fit_hawkes_mle_alpha_mu_beta(
        world=world,
        n_lags=n_lags,
        y=y,
        init_alpha=init_alpha,
        init_beta=init_beta,
        maxiter=maxiter,
    )

    payload = {
        "mu": np.asarray(fit["mu"], dtype=float).tolist(),
        "alpha": float(fit["alpha"]),
        "beta": float(fit["beta"]),
        "loglik": float(fit["loglik"]),
        "loglik_init": float(fit["loglik_init"]),
        "success": bool(getattr(fit["result"], "success", False)),
        "message": str(getattr(fit["result"], "message", "")),
    }

    typer.echo(json.dumps(payload))


@sim_app.command("fit-observed")
def sim_fit_observed(
    parquet: str = typer.Option(..., "--parquet", help="Path to simulation parquet."),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    maxiter: int = typer.Option(600, "--maxiter", min=1),
) -> None:
    """Fit (mu, alpha) from y_obs using Poisson approximation.

    Requires that the parquet was generated by our simulator so that y_true is
    available to construct the Hawkes history term.
    """

    import json

    import numpy as np

    from ...sim import load_simulation_parquet
    from ...sim.fit import fit_hawkes_mle_alpha_mu_observed_poisson_approx

    loaded = load_simulation_parquet(path=parquet)
    world = loaded["world"]
    params = loaded["params"]

    fit = fit_hawkes_mle_alpha_mu_observed_poisson_approx(
        world=world,
        kernel=params.kernel,
        y_true_for_history=loaded["y_true"],
        y_obs=loaded["y_obs"],
        p_detect=float(params.p_detect),
        false_rate=float(params.false_rate),
        init_alpha=init_alpha,
        maxiter=maxiter,
    )

    payload = {
        "mu": np.asarray(fit["mu"], dtype=float).tolist(),
        "alpha": float(fit["alpha"]),
        "loglik": float(fit["loglik"]),
        "loglik_init": float(fit["loglik_init"]),
        "success": bool(getattr(fit["result"], "success", False)),
        "message": str(getattr(fit["result"], "message", "")),
    }

    typer.echo(json.dumps(payload))


def _load_y_obs(path: str):
    import numpy as np

    p = str(path)
    y = np.load(p) if p.endswith(".npy") else np.loadtxt(p, delimiter=",")

    y = np.asarray(y)
    if y.ndim != 2:
        raise ValueError("y_obs must be a 2D array (n_locations, n_steps)")
    return y


@sim_app.command("forecast-observed")
def sim_forecast_observed(
    y_obs_path: str = typer.Option(
        ..., "--y-obs", help="Path to y_obs as CSV (rows=locations) or .npy."
    ),
    out_path: str | None = typer.Option(
        None,
        "--out",
        help="Optional path to write JSON output (stdout is always printed).",
    ),
    q: str = typer.Option(
        "0.05,0.5,0.95",
        "--q",
        help="Comma-separated quantiles for predictive summaries (e.g. 0.05,0.5,0.95).",
    ),
    horizon: int = typer.Option(20, "--horizon", min=1),
    n_paths: int = typer.Option(200, "--n-paths", min=1),
    seed: int = typer.Option(123, "--seed"),
    p_detect: float = typer.Option(1.0, "--p-detect", min=0.0, max=1.0),
    false_rate: float = typer.Option(0.0, "--false-rate", min=0.0),
    n_lags: int = typer.Option(6, "--n-lags", min=1),
    beta: float = typer.Option(1.0, "--beta", min=1e-12),
    init_alpha: float = typer.Option(0.1, "--init-alpha", min=0.0),
    maxiter: int = typer.Option(600, "--maxiter", min=1),
) -> None:
    """Observed-only forecast: fit -> sample -> summarize (Poisson approximation)."""

    import json

    import numpy as np

    from ...sim import generate_random_world
    from ...sim.hawkes import discrete_exponential_kernel
    from ...sim.workflows import observed_fit_sample_summarize_poisson_approx

    y_obs = _load_y_obs(y_obs_path).astype(int)
    world = generate_random_world(n_locations=y_obs.shape[0], seed=0, lengthscale=0.5)
    kernel = discrete_exponential_kernel(n_lags=n_lags, beta=float(beta))

    try:
        q_levels = tuple(float(x) for x in q.split(",") if x.strip() != "")
    except ValueError as e:
        raise typer.BadParameter("--q must be comma-separated numbers") from e

    if len(q_levels) == 0:
        raise typer.BadParameter("--q must specify at least one quantile")
    if any((qq < 0.0) or (qq > 1.0) for qq in q_levels):
        raise typer.BadParameter("--q quantiles must be in [0,1]")

    result = observed_fit_sample_summarize_poisson_approx(
        world=world,
        kernel=kernel,
        y_obs=y_obs,
        p_detect=float(p_detect),
        false_rate=float(false_rate),
        horizon=horizon,
        n_paths=n_paths,
        seed=seed,
        q=q_levels,
        init_alpha=float(init_alpha),
        fit_maxiter=int(maxiter),
    )

    fit = result["fit"]
    summary = result["summary"]

    payload = {
        "meta": {
            "n_locations": int(y_obs.shape[0]),
            "horizon": int(horizon),
            "n_paths": int(n_paths),
            "n_lags": int(n_lags),
            "beta": float(beta),
        },
        "fit": {
            "mu": np.asarray(fit["mu"], dtype=float).tolist(),
            "alpha": float(fit["alpha"]),
            "loglik": float(fit["loglik"]),
            "loglik_init": float(fit["loglik_init"]),
            "success": bool(getattr(fit["result"], "success", False)),
            "message": str(getattr(fit["result"], "message", "")),
        },
        "predict": {
            "q": [float(x) for x in summary.get("q", q_levels)],
            "mean": np.asarray(summary["mean"], dtype=float).tolist(),
            "quantiles": np.asarray(summary["quantiles"], dtype=float).tolist(),
        },
    }

    text = json.dumps(payload)
    typer.echo(text)
    if out_path is not None:
        from pathlib import Path

        Path(out_path).write_text(text)
